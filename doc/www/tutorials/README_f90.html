<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1" />
<link rel="stylesheet" href="../robodoc.css" type="text/css" />
<title>./src/tutorials/README.f90</title>
<!-- Source: ./src/tutorials/README.f90 -->
<!-- Generated with ROBODoc Version 4.99.30 (Jun 25 2008) -->
</head>
<body>
<div id="logo">
<a name="robo_top_of_doc">ETSF_IO library - documentation pages</a>
</div> <!-- logo -->
<div id="navigation">
</div> <!-- navigation -->
<div id="content">
<h3>TABLE OF CONTENTS</h3>
<ul>
<li><a href="#robo119">etsf_io_tutorials</a></li>
<ul>
<li><a href="./convert_to_xyz_f90.html#robo4">convert_to_xyz</a></li>
<li><a href="./create_a_crystal_den_file_f90.html#robo5">create_a_crystal_den_file</a></li>
<li><a href="./mix_ETSF_and_non_ETSF_f90.html#robo128">mix_ETSF_and_non_ETSF</a></li>
<li><a href="./MPI_output_of_a_density_f90.html#robo129">MPI_output_of_a_density</a></li>
<li><a href="./read_a_file_f90.html#robo131">read_a_file</a></li>
<li><a href="./read_write_sub_access_f90.html#robo132">read_write_sub_access</a></li>
</ul>
</ul>
<hr />
<a name="tutorials2fetsf5fio5ftutorials">
</a><a name="robo119"></a><h2>etsf_io_tutorials</h2>

<p>[ <a href="#robo_top_of_doc">Top</a> ] [ <a href="../robo_sub_cat.html#robo_top_of_doc">Sub categories</a> ]</p>
<p class="item_name">NAME</p>
<p>  <strong>etsf_io_tutorials</strong> -- ESTF I/O examples and tutorials
</p>
<p class="item_name">FUNCTION</p>
<p>  Tutorials are directly Fortran source code, highly commented, located in
  src/tutorials. These codes can be compiled and executed to create example
  files.
</p>

<p>  The following tutorials are available:
</p>
<ul><li>  Tutorial 1 - basics of file creation
    <a href="./create_a_crystal_den_file_f90.html#robo5">create_a_crystal_den_file</a>, the first tutorial, is intended to explain the
    basics and the philosophy of this library. It details the first steps
    required to create a density file, using high level routines
    (etsf_io_data_&lt;action&gt;). It shows how to use the pointers and the unformatted
    ones (used to map any shape arrays between the ETSF definition and the main
    program memory).
</li>
<li>  Tutorial 2 - advanced writing, sub-access on k point and spin
    <a href="./read_write_sub_access_f90.html#robo132">read_write_sub_access</a>, the second tutorial, introduces the group level
    routines and explain how to access only sub part of arrays. This sub access
    is possible when one array has a dimension on spin or k points. Then one can
    access data for one k point or spin at a time. This is controlled by some
    attributes in the concerned groups, called
    &lt;short_var_name&gt;__[spin|kpoint]_access&lt;/code&gt;. In this tutorial a
    wave-function file is created and the coefficients of wave-functions are
    written for one k point at a time.
</li>
<li>  Tutorial 3 - a converter tool, usage of validity checks
    <a href="./convert_to_xyz_f90.html#robo4">convert_to_xyz</a>, the third tutorial, shows how to use high level modules
    <a href="../utils/etsf_io_file_f90.html#robo1">etsf_io_file</a> and <a href="../utils/etsf_io_tools_f90.html#robo3">etsf_io_tools</a> to check the conformance of an input ETSF file
    on cristalographic specifications and then to read atomic coordinates and
    names to create a simple XYZ file.
</li>
<li>  Tutorial 4 - how to use split capabilities in conjonction with MPI?
    <a href="./MPI_output_of_a_density_f90.html#robo129">MPI_output_of_a_density</a>, the fourth tutorial, shows how to use the split
    definitions as defined in the specifications to handle MPI computations. This
    is possible with the help of the <a href="../group_level/etsf_io_f90.html#robo124">etsf_split</a> structure. This tutorial create a
    density file with a paralelisation on z planes. Each process compute a
    gaussian in its own z planes and create an ETSF file with a split on
    number_of_grid_points_vector3. Thanks to <a href="../group_level/etsf_io_f90.html#robo0">etsf_io</a> the created files can be then
    gathered into one unique file.
</li>
<li>  Tutorial 5 - mixing ETSF and non-ETSF variables in file creation (tutorial 1 enhancement)
    <a href="./mix_ETSF_and_non_ETSF_f90.html#robo128">mix_ETSF_and_non_ETSF</a>, the fifth tutorial, is not focus on the low level API
    but it uses it in several areas. This tutorial shows how to write an ETSF file
    with additional non-ETSF variables. These variables are defined and written
    directly by using the low level API. Besides it also shows how to use the
    etsf_io_&lt;group&gt;_put() methods in the context of a concurrent list of ETSF and
    non-ETSF variables.
</li>
<li>  Tutorial 6 - simple read of a wavefunction file (continuation of tutorial 2)
    <a href="./read_a_file_f90.html#robo131">read_a_file</a>, the sixth tutorial, introduces the read actions in a simple case.
    Here, we know that the file should contains the variables of a wavefunction
    description. This tutorial uses the file created by tutorial 2 but does not
    read it with sub access. Everything is read once as a bloc.
</li>
</ul>
<p></p>

</div> <!-- content -->
<div id="footer">
<p>Generated from ./src/tutorials/README.f90 with <a href="http://www.xs4all.nl/~rfsber/Robo/robodoc.html">ROBODoc</a> V4.99.30 on Mon Mar 29 2010 11:04:45
</p>
</div> <!-- footer -->
</body>
</html>
