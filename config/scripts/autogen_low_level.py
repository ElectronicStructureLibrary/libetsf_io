#!/usr/bin/env python
#
# Copyright (C) 2006, 2007 (Damien Caliste)
# All rights reserved.
#
# This file is part of the ETSF_IO software package. For license information,
# please see the COPYING file in the top-level directory of the library source
# distribution.
#

from time import gmtime,strftime

import subprocess
import os
import re
import sys

# ---------------------------------------------------------------------------- #

#
# Main program
#

# Initial setup
my_name    = "autogen_low_level.py"
my_configs = ["config/etsf/code.cf"]

# Check if we are in the top of the ETSF_IO source tree
if ( not os.path.exists("configure.ac") ):
 print("%s: You must be in the top of the library source tree." % my_name)
 print("%s: Aborting now." % my_name)
 sys.exit(1)

# Read config file(s)
for cnf in my_configs:
 if ( os.path.exists(cnf) ):
  exec(compile(open(cnf, "rb").read(), cnf, 'exec'))
 else:
  print("%s: Could not find config file (%s)." % (my_name,cnf))
  print("%s: Aborting now." % my_name)
  sys.exit(2)

# This script auto generate the read method for the nD dimensional arrays.
# It create a new file for thiese read routines.
NC_ACTION       = (("read",  "src/low_level/read_routines_auto.f90"), \
                   ("write", "src/low_level/write_routines_auto.f90"))
GENERATED_TYPES = ("integer",  "double",      "character")
NF90_TYPES      = ("NF90_INT", "NF90_DOUBLE", "NF90_CHAR")

ATT_GENERATED_TYPES = ("integer",  "real",       "double",      "character")
ATT_NF90_TYPES      = ("NF90_INT", "NF90_FLOAT", "NF90_DOUBLE", "NF90_CHAR")

# Create a warning banner
banner  = "!================================================================\n"
banner += "! WARNING! this file is autogenerated. All modifications should\n"
banner += "! will be overwritten on next build. This file is automatically\n"
banner += "! produced by the config/scripts/%s.\n" % my_name
banner += "!================================================================\n"

# We load the template and replace in it.
var_template = open("config/etsf/template.low_level_var", "r").read()
att_template = open("config/etsf/template.low_level_att", "r").read()

for (action, tgt_file) in NC_ACTION:
  if (action == "read"):
    inout = "out"
    ncaction = "get"
  else:
    inout = "in"
    ncaction = "put"
    
  ret = ""
  # We create the new routines to access variables.
  for i in range(len(GENERATED_TYPES)):
    type   = GENERATED_TYPES[i]
    nctype = NF90_TYPES[i]
    # We customize the type for the Fortran argument declaration.
    if (type == "character"):
      fortrantype = 'character(len = charlen)'
      # When character are concerned, one dimension is reserved for the length.
      start       = 2
      dimstart    = 1
      addarg      = ', charlen'
      charcomment = ""
    else:
      if (type == "double"):
        fortrantype = 'double precision'
      else:
        fortrantype = GENERATED_TYPES[i]
      start       = 1
      dimstart    = 0
      addarg      = ""
      charcomment = '!'
    for dim in range(dimstart,8):
      # We create the dimension declaration for the var array.
      if (start <= dim):
        vardims    = "("
        for j in range(start,dim):
          vardims  = vardims + ":,"
        vardims    = vardims + ":)"
        addcomment = ""
      else:
        vardims    = ""
        addcomment = '!'

      # We create the routine stuffs
      routine_name  = "%s_var_%s_%dD" % (action, type, dim)
      routine_arg   = "ncid, varname, var%s, lstat, &\n" % addarg \
                    + "    & start, count, map, ncvarid, error_data"
      arg_desc      = \
         "  integer, intent(in)                            :: ncid%s\n" % addarg \
       + "  %s, intent(%s) :: var%s\n" % (fortrantype, inout, vardims)
      user_var_desc = \
         "  var_user%name = varname\n" \
       + "  var_user%%nctype = %s\n" % nctype \
       + "  var_user%%ncshape = %d\n" % dim \
       + "  %svar_user%%ncdims(%d:%d) = shape(var)\n" % (addcomment, start, dim)\
       + "  %svar_user%%ncdims(1) = charlen\n" % charcomment
      action_src    = \
         "  s = nf90_%s_var(ncid, var_nc%%ncid, values = var, &\n" % ncaction \
       + "                 & start = my_start(1:max(1, var_nc%ncshape)) &\n" \
       + "  %s               & ,count = my_count(1:max(1, var_nc%%ncshape)) &\n" % addcomment \
       + "  %s               & ,map = my_map(1:max(1, var_nc%%ncshape)) &\n"  % addcomment \
       + "                 & )\n"
       
      # We replace in the template.
      sub_src = re.sub("@SUB_NAME@", routine_name, var_template)
      sub_src = re.sub("@ARG_LIST@", routine_arg, sub_src)
      sub_src = re.sub("@ARG_DESC@\n", arg_desc, sub_src)
      sub_src = re.sub("@USER_VAR_DESC@\n", user_var_desc, sub_src)
      sub_src = re.sub("@ACTION@\n", action_src, sub_src)
      ret += sub_src + "\n"
    
  # We create the file
  out = open("%s/%s_routines_auto.f90" % (etsf_low_level_file_srcdir, action), "w")
  out.write(banner + "\n" + ret)
  out.close()


  # ATTRIBUTES --------------------

  # We create the new routines to access attributes.
  for i in range(len(ATT_GENERATED_TYPES)):
    type   = ATT_GENERATED_TYPES[i]
    nctype = ATT_NF90_TYPES[i]
    # We customize the type for the Fortran argument declaration.
    if (type == "character"):
      if (action == "read"):
        fortrantype = 'character(len = attlen)'
      else:
        fortrantype = 'character(len = *)'
      # When character are concerned, one dimension is reserved for the length.
      start       = 1
    else:
      if (type == "double"):
        fortrantype = 'double precision'
      else:
        fortrantype = ATT_GENERATED_TYPES[i]
      start       = 0
    for dim in range(start,2):
      init = ""
      # The att argument must be filled with space because netcdf
      # will only write the length of the attribute from the file
      # and the remaining in att will be garbage.
      if (type == "character" and action == "read"):
        init    = 'write(att, "(A)") repeat(" " , attlen)'
      # Array or not
      if (dim == 1):
        if (action == "write"):
          dimarg     = ""
          if (type == "character"):
            vardims    = ""
          else:
            vardims    = "(:)"
          dimcomment = "!"
          attlen     = "trim_len(att)"
        else:
          dimarg     = ", attlen"
          if (type == "character"):
            vardims    = ""
          else:
            vardims    = "(1:attlen)"
          dimcomment = ""
          attlen     = "attlen"
      else:
        dimarg     = ""
        vardims    = ""
        dimcomment = "!"
        attlen     = "1"
      # Access by id or by name
      for var_access in ["name", "id"]:
        if (var_access == "name"):
          # Access by name
          subname     = ""
          subargname  = "varname"
          subargtype  = "character(len = *)"
          subarglocal = "  type(etsf_io_low_var_infos) :: var_infos"
          subvarid    = "var_infos%ncid"
        else:
          # Access by id
          subname     = "id_"
          subargname  = "ncvarid"
          subargtype  = "integer"
          subarglocal = ""
          subvarid    = subargname

        # We create the routine stuffs
        routine_name  = "%s_att_%s%s_%dD" % (action, subname, type, dim)
        routine_arg   = "ncid, %s, attname%s, att, &\n" % (subargname, dimarg) \
                      + "    & lstat, error_data"
        arg_desc      = \
           "  %s, intent(in)                            :: %s\n" % (subargtype, subargname) \
         + "  %sinteger, intent(in)                            :: attlen\n" % dimcomment \
         + "  %s, intent(%s)                    :: att%s\n" % (fortrantype, inout, vardims)
        if (var_access == "name"):
          var_access_src = \
             "  if (present(error_data)) then\n" \
           + "    call etsf_io_low_read_var_infos(ncid, %s, var_infos, &\n" % subargname \
           + "                                  & lstat, error_data = error_data)\n" \
           + "    if (.not. lstat) call etsf_io_low_error_update(error_data, me)\n" \
           + "  else\n" \
           + "    call etsf_io_low_read_var_infos(ncid, %s, var_infos, lstat)\n" % subargname \
           + "  end if\n" \
           + "  if (.not. lstat) return\n"
        else:
          var_access_src = ""
        if (action == "read"):
          checks = \
               "  ! We first check the definition of the attribute (name, type and dims)\n" \
             + "  if (present(error_data)) then\n" \
             + "    call etsf_io_low_check_att(ncid, %s, attname, %s, &\n" % (subvarid, nctype) \
             + "                             & %s, lstat, error_data = error_data)\n" % (attlen) \
             + "    if (.not. lstat) call etsf_io_low_error_update(error_data, me)\n" \
             + "  else\n" \
             + "    call etsf_io_low_check_att(ncid, %s, attname, %s, &\n" % (subvarid, nctype) \
             + "                             & %s, lstat)\n" % (attlen) \
             + "  end if\n" \
             + "  if (.not. lstat) return\n"
        else:
          checks = ""
        action_src = \
             "  s = nf90_%s_att(ncid, %s, attname, att)\n" % (ncaction, subvarid)
        error = \
             "      call etsf_io_low_error_set(error_data, ERROR_MODE_GET, ERROR_TYPE_ATT, &\n" \
           + "                    & me, tgtname = attname, tgtid = %s, errid = s, &\n" % subvarid \
           + "                    & errmess = nf90_strerror(s))\n"
         
        # We replace in the template.
        sub_src = re.sub("@SUB_NAME@", routine_name, att_template)
        sub_src = re.sub("@ARG_LIST@", routine_arg, sub_src)
        sub_src = re.sub("@ARG_DESC@\n", arg_desc, sub_src)
        sub_src = re.sub("@ARG_LOCAL@\n", subarglocal, sub_src)
        sub_src = re.sub("@INIT@", init, sub_src)
        sub_src = re.sub("@VAR_GET_ID@\n", var_access_src, sub_src)
        sub_src = re.sub("@CHECKS@\n", checks, sub_src)
        sub_src = re.sub("@ACTION@\n", action_src, sub_src)
        sub_src = re.sub("@SET_ERROR@\n", error, sub_src)
        ret += sub_src + "\n"
    
  # We create the file
  out = open("%s/%s_routines_auto.f90" % (etsf_low_level_file_srcdir, action), "w")
  out.write(banner + "\n" + ret)
  out.close()
  
